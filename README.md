# 几何序列排列问题

## 问题描述

给定一个长度为N的整数序列A=(A₁, A₂, ..., Aₙ)，其中每个元素都不为0。判断是否存在A的一个排列B=(B₁, B₂, ..., Bₙ)，使得B构成一个几何序列。

一个序列S=(S₁, S₂, ..., Sₙ)是几何序列，当且仅当存在一个实数r，使得对于所有1≤i<N，都有S_{i+1} = r·S_i。

## 算法思路

### 核心思想
1. **特殊情况处理**：
   - 如果序列长度≤2，总是可以形成几何序列
   - 如果所有数字都相同，可以形成几何序列（公比为1）

2. **枚举起始数字对**：
   - 尝试所有可能的第一和第二个数字组合
   - 计算公比 r = a₂/a₁

3. **验证几何序列**：
   - 根据公比计算几何序列中的后续数字
   - 检查计算出的数字是否在原始序列中存在
   - 使用分数形式避免浮点精度问题

### 时间复杂度
- 对于每个测试用例：O(k²·n)，其中k是不同数字的个数，n是序列长度
- 总体复杂度：O(T·k²·n)

## 文件说明

- `geometric_sequence_correct.cpp`：最终的正确解决方案
- `test_input.txt`：测试输入文件
- `README.md`：说明文档

## 使用方法

```bash
# 编译
g++ -o geometric_sequence geometric_sequence_correct.cpp

# 运行（从文件输入）
./geometric_sequence < test_input.txt

# 运行（从标准输入）
./geometric_sequence
```

## 示例

### 输入
```
3
5
1 8 2 4 16
5
-16 24 54 81 -36
7
90000 8100 -27000 729 -300000 -2430 1000000
```

### 输出
```
Yes
No
Yes
```

### 解释
1. 第一个测试用例：可以重排为(16,8,4,2,1)，公比为1/2
2. 第二个测试用例：无法重排成几何序列
3. 第三个测试用例：可以重排成几何序列

## 关键实现细节

1. **避免浮点误差**：使用分数形式进行计算，避免浮点精度问题
2. **整数除法检查**：确保计算出的数字是整数
3. **计数管理**：使用map来管理每个数字的出现次数
4. **溢出处理**：使用long long类型避免整数溢出
